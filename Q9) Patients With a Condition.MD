A)
return patients.loc[patients["conditions"].str.contains(r"\bDIAB1\b", na=False, regex=True),
["patient_id","patient_name","conditions"]]    


r"\bDIAB1\b"  
r""
Raw string  

\b (word boundary)  
ğŸ‘‰ â€œThe character before/after must NOT be a letter, number, or underscore.â€   
   
What matches âœ…  
"DIAB1"                      
"ACNE DIAB1"              
"DIAB1 HYPERTENSION"           
"DIAB1, ASTHMA"                        
Because space, comma, start/end of string = valid boundaries.          
              
What does NOT match âŒ              
"SADIAB100" â†’ letters touching it                     
"DIAB12" â†’ number touching it                   
"XDIAB1Y" â†’ letters hugging it on both sides            

--- 

ERROR:                               
return patients.loc[patients["conditions"].str.startswith("DIAB1"),["patient_id","patient_name","conditions"]]        

---

That only catches rows where the string begins with "DIAB1"
Fails For  

| patient_id | patient_name | conditions   |   
| ---------- | ------------ | ------------ | 
| 3          | Bob          | DIAB100 MYOP |    
| 4          | George       | ACNE DIAB100 |  

---  
FIX:  

return patients.loc[
    patients["conditions"].str.contains("DIAB1", na=False),
    ["patient_id", "patient_name", "conditions"]]

But Fails in Testcase
---  

How:
str.contains("DIAB1") â†’ finds it anywhere inside the text
na=False â†’ avoids crashing if a row has missing values  

---  
 
| conditions         | startswith | contains |  
| ------------------ | ---------- | -------- |  
| DIAB1              | âœ…          | âœ…        |  
| ACNE DIAB1         | âŒ          | âœ…        |  
| DIAB1 HYPERTENSION | âœ…          | âœ…        |  
  
